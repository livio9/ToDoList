# 数据层实现详解

## 数据模型设计

ToDoList应用的核心数据模型是围绕待办事项（Todo）和任务组（TaskGroup）设计的，这些模型类使用Room注解定义了数据库表结构。

### Todo类（待办事项）

```java
@Entity(tableName = "todos")
public class Todo implements Serializable {
    @PrimaryKey
    @NonNull
    public String id;                // 唯一标识符
    
    public String title;             // 任务标题
    public long time;                // 任务时间戳
    public String place;             // 任务地点
    public String category;          // 任务分类
    public boolean completed;        // 完成状态
    public String priority;          // 优先级：高、中、低
    
    // 番茄工作法相关字段
    @ColumnInfo(defaultValue = "0")
    public Boolean pomodoroEnabled;  // 是否启用番茄钟
    public int pomodoroMinutes;      // 专注总分钟数
    public int pomodoroCompletedCount; // 已完成番茄钟次数
    
    // 数据管理字段
    public long createdAt;           // 创建时间
    public long updatedAt;           // 更新时间
    @ColumnInfo(defaultValue = "0")
    public boolean deleted;          // 软删除标记
    
    // 关系字段
    @ColumnInfo(defaultValue = "0")
    public boolean belongsToTaskGroup; // 是否属于代办集
    public String groupId;           // 所属任务组ID
    
    // 积分系统
    public int points;               // 任务积分
    
    // 默认构造函数（Room和Firestore需要）
    public Todo() {
        this.id = UUID.randomUUID().toString();
        this.createdAt = System.currentTimeMillis();
        this.updatedAt = this.createdAt;
    }
    
    // 带参数的构造函数
    @Ignore
    public Todo(String title, long time, String place, String category, String priority) {
        this();
        this.title = title;
        this.time = time;
        this.place = place;
        this.category = category;
        this.priority = priority;
        this.completed = false;
        this.deleted = false;
        this.belongsToTaskGroup = false;
        this.pomodoroEnabled = false;
        this.points = calculatePoints(); // 根据任务属性计算积分
    }
    
    // 计算任务积分
    public int calculatePoints() {
        // 基础分值
        int basePoints = 10;
        
        // 根据优先级调整分值
        if (priority != null) {
            switch (priority) {
                case "高":
                    basePoints += 10;
                    break;
                case "中":
                    basePoints += 5;
                    break;
                case "低":
                    basePoints += 2;
                    break;
            }
        }
        
        // 使用番茄钟的额外奖励
        if (pomodoroEnabled != null && pomodoroEnabled) {
            basePoints += 5;
        }
        
        return basePoints;
    }
    
    // 更新任务修改时间
    public void touch() {
        this.updatedAt = System.currentTimeMillis();
    }
    
    // 判断任务是否已过期
    public boolean isOverdue() {
        return !completed && time > 0 && time < System.currentTimeMillis();
    }
}
```

### TaskGroup类（任务组）

```java
@Entity(tableName = "task_groups")
public class TaskGroup implements Serializable {
    @PrimaryKey
    @NonNull
    public String id;                // 唯一标识符
    
    public String title;             // 任务组标题
    public String description;       // 任务组描述
    public String category;          // 任务组分类
    
    // 时间相关
    public long createdAt;           // 创建时间
    public long updatedAt;           // 更新时间
    @ColumnInfo(defaultValue = "0")
    public long dueDate;             // 截止日期
    
    // 数据管理
    @ColumnInfo(defaultValue = "0")
    public boolean deleted;          // 软删除标记
    
    // 额外属性
    public int colorCode;            // 颜色代码
    public String icon;              // 图标名称
    
    // 默认构造函数
    public TaskGroup() {
        this.id = UUID.randomUUID().toString();
        this.createdAt = System.currentTimeMillis();
        this.updatedAt = this.createdAt;
    }
    
    // 带参数的构造函数
    @Ignore
    public TaskGroup(String title, String description, String category) {
        this();
        this.title = title;
        this.description = description;
        this.category = category;
        this.deleted = false;
        
        // 默认颜色和图标
        this.colorCode = getDefaultColorForCategory(category);
        this.icon = getDefaultIconForCategory(category);
    }
    
    // 获取分类对应的默认颜色
    private int getDefaultColorForCategory(String category) {
        if (category == null) return Color.parseColor("#5C6BC0");
        
        switch (category) {
            case "工作":
                return Color.parseColor("#E53935"); // 红色
            case "学习":
                return Color.parseColor("#43A047"); // 绿色
            case "生活":
                return Color.parseColor("#1E88E5"); // 蓝色
            case "健康":
                return Color.parseColor("#8E24AA"); // 紫色
            default:
                return Color.parseColor("#5C6BC0"); // 默认蓝紫色
        }
    }
    
    // 获取分类对应的默认图标
    private String getDefaultIconForCategory(String category) {
        if (category == null) return "ic_group_default";
        
        switch (category) {
            case "工作":
                return "ic_work";
            case "学习":
                return "ic_study";
            case "生活":
                return "ic_life";
            case "健康":
                return "ic_health";
            default:
                return "ic_group_default";
        }
    }
    
    // 更新修改时间
    public void touch() {
        this.updatedAt = System.currentTimeMillis();
    }
}
```

这种数据模型设计考虑了以下几个方面：

1. **业务需求**：包含了任务管理所需的所有字段
2. **数据完整性**：使用非空主键和默认值确保数据有效
3. **软删除**：使用deleted标记实现回收站功能
4. **关系建模**：通过groupId字段表示任务与任务组的关系
5. **扩展性**：包含额外属性为未来功能预留空间

## Room数据库应用

ToDoList使用Room持久化库作为本地数据存储的解决方案，它提供了对SQLite的友好封装，使数据库操作更加直观和安全。

### 数据库配置

```java
@Database(
    entities = {Todo.class, TaskGroup.class, User.class},
    version = 7,
    exportSchema = false
)
@TypeConverters(Converters.class)
public abstract class AppDatabase extends RoomDatabase {
    private static final String DATABASE_NAME = "todolist_database";
    private static volatile AppDatabase instance;
    
    // 数据访问对象
    public abstract TaskDao taskDao();
    public abstract TaskGroupDao taskGroupDao();
    public abstract UserDao userDao();
    
    // 单例模式获取数据库实例
    public static AppDatabase getInstance(Context context) {
        if (instance == null) {
            synchronized (AppDatabase.class) {
                if (instance == null) {
                    instance = Room.databaseBuilder(
                            context.getApplicationContext(),
                            AppDatabase.class,
                            DATABASE_NAME)
                            .addMigrations(
                                MIGRATION_1_2,
                                MIGRATION_2_3,
                                MIGRATION_3_4,
                                MIGRATION_4_5,
                                MIGRATION_5_6,
                                MIGRATION_6_7
                            )
                            .build();
                }
            }
        }
        return instance;
    }
    
    // 数据库版本迁移策略
    static final Migration MIGRATION_1_2 = new Migration(1, 2) {
        @Override
        public void migrate(SupportSQLiteDatabase database) {
            // 添加priority字段
            database.execSQL("ALTER TABLE todos ADD COLUMN priority TEXT DEFAULT '中'");
        }
    };
    
    static final Migration MIGRATION_2_3 = new Migration(2, 3) {
        @Override
        public void migrate(SupportSQLiteDatabase database) {
            // 添加番茄时钟相关字段
            database.execSQL("ALTER TABLE todos ADD COLUMN pomodoroEnabled INTEGER DEFAULT 0");
            database.execSQL("ALTER TABLE todos ADD COLUMN pomodoroMinutes INTEGER DEFAULT 0");
            database.execSQL("ALTER TABLE todos ADD COLUMN pomodoroCompletedCount INTEGER DEFAULT 0");
        }
    };
    
    // 更多的迁移策略...
    
    static final Migration MIGRATION_6_7 = new Migration(6, 7) {
        @Override
        public void migrate(SupportSQLiteDatabase database) {
            // 添加任务组截止日期字段
            database.execSQL("ALTER TABLE task_groups ADD COLUMN dueDate INTEGER DEFAULT 0");
            // 添加积分字段
            database.execSQL("ALTER TABLE todos ADD COLUMN points INTEGER DEFAULT 10");
        }
    };
}
```

### 类型转换器

```java
public class Converters {
    // Date与Long转换
    @TypeConverter
    public static Date fromTimestamp(Long value) {
        return value == null ? null : new Date(value);
    }
    
    @TypeConverter
    public static Long dateToTimestamp(Date date) {
        return date == null ? null : date.getTime();
    }
    
    // List<String>与String转换
    @TypeConverter
    public static List<String> fromString(String value) {
        if (value == null) {
            return Collections.emptyList();
        }
        Type listType = new TypeToken<List<String>>() {}.getType();
        return new Gson().fromJson(value, listType);
    }
    
    @TypeConverter
    public static String fromStringList(List<String> list) {
        if (list == null) {
            return null;
        }
        Gson gson = new Gson();
        return gson.toJson(list);
    }
}
```

## 数据访问对象(DAO)

DAO接口定义了数据库操作方法，使用SQL查询语句和Room注解完成数据访问，避免了手写SQL的繁琐和错误。

### TaskDao

```java
@Dao
public interface TaskDao {
    // 基本CRUD操作
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void insertTodo(Todo todo);
    
    @Update
    void updateTodo(Todo todo);
    
    @Delete
    void deleteTodo(Todo todo);
    
    // 查询单个任务
    @Query("SELECT * FROM todos WHERE id = :todoId")
    Todo getTodoById(String todoId);
    
    // 获取所有可见任务（未删除）
    @Query("SELECT * FROM todos WHERE deleted = 0 ORDER BY time ASC")
    List<Todo> getVisibleTodos();
    
    // 获取所有可见且未完成的任务
    @Query("SELECT * FROM todos WHERE deleted = 0 AND completed = 0 ORDER BY time ASC")
    List<Todo> getActiveTodos();
    
    // 获取特定时间范围内的任务
    @Query("SELECT * FROM todos WHERE deleted = 0 AND time >= :startTime AND time <= :endTime ORDER BY time ASC")
    List<Todo> getTodosInTimeRange(long startTime, long endTime);
    
    // 按类别获取任务
    @Query("SELECT * FROM todos WHERE deleted = 0 AND category = :category ORDER BY time ASC")
    List<Todo> getTodosByCategory(String category);
    
    // 获取任务组内的任务
    @Query("SELECT * FROM todos WHERE deleted = 0 AND belongsToTaskGroup = 1 AND groupId = :groupId ORDER BY time ASC")
    List<Todo> getTodosByGroupId(String groupId);
    
    // 统计查询：获取任务总数
    @Query("SELECT COUNT(*) FROM todos WHERE deleted = 0")
    int getTotalTaskCount();
    
    // 统计查询：获取已完成任务数
    @Query("SELECT COUNT(*) FROM todos WHERE deleted = 0 AND completed = 1")
    int getCompletedTaskCount();
    
    // 统计查询：按类别统计任务数量
    @Query("SELECT category, COUNT(*) as count FROM todos WHERE deleted = 0 GROUP BY category")
    List<CategoryCount> getTaskCountByCategory();
    
    // 标记任务为已删除（软删除）
    @Query("UPDATE todos SET deleted = 1, updatedAt = :timestamp WHERE id = :todoId")
    void logicalDeleteTodo(String todoId, long timestamp);
    
    // 清空回收站（物理删除已标记删除的任务）
    @Query("DELETE FROM todos WHERE deleted = 1")
    void emptyTrash();
    
    // LiveData查询：获取可观察的任务列表
    @Query("SELECT * FROM todos WHERE deleted = 0 ORDER BY time ASC")
    LiveData<List<Todo>> getObservableTodos();
    
    // 批量操作：插入多个任务
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void insertTodos(List<Todo> todos);
    
    // 批量操作：更新多个任务
    @Update
    void updateTodos(List<Todo> todos);
    
    // 全文搜索：按标题或地点搜索任务
    @Query("SELECT * FROM todos WHERE deleted = 0 AND (title LIKE '%' || :query || '%' OR place LIKE '%' || :query || '%')")
    List<Todo> searchTodos(String query);
}
```

### TaskGroupDao

```java
@Dao
public interface TaskGroupDao {
    // 基本CRUD操作
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    void insertTaskGroup(TaskGroup taskGroup);
    
    @Update
    void updateTaskGroup(TaskGroup taskGroup);
    
    @Delete
    void deleteTaskGroup(TaskGroup taskGroup);
    
    // 查询单个任务组
    @Query("SELECT * FROM task_groups WHERE id = :groupId")
    TaskGroup getTaskGroupById(String groupId);
    
    // 获取所有未删除的任务组
    @Query("SELECT * FROM task_groups WHERE deleted = 0 ORDER BY updatedAt DESC")
    List<TaskGroup> getVisibleTaskGroups();
    
    // 按类别获取任务组
    @Query("SELECT * FROM task_groups WHERE deleted = 0 AND category = :category ORDER BY title ASC")
    List<TaskGroup> getTaskGroupsByCategory(String category);
    
    // 标记任务组为已删除（软删除）
    @Query("UPDATE task_groups SET deleted = 1, updatedAt = :timestamp WHERE id = :groupId")
    void logicalDeleteTaskGroup(String groupId, long timestamp);
    
    // 统计查询：获取任务组中已完成的任务比例
    @Query("SELECT tg.id, tg.title, COUNT(t.id) as totalTasks, " +
           "SUM(CASE WHEN t.completed = 1 THEN 1 ELSE 0 END) as completedTasks " +
           "FROM task_groups tg LEFT JOIN todos t ON tg.id = t.groupId " +
           "WHERE tg.deleted = 0 AND (t.deleted = 0 OR t.deleted IS NULL) " +
           "GROUP BY tg.id")
    List<TaskGroupProgress> getTaskGroupsProgress();
    
    // LiveData查询：获取可观察的任务组列表
    @Query("SELECT * FROM task_groups WHERE deleted = 0 ORDER BY updatedAt DESC")
    LiveData<List<TaskGroup>> getObservableTaskGroups();
}
```

## Room数据库最佳实践

ToDoList项目在使用Room数据库时采用了以下最佳实践：

1. **单例模式**：使用双重检查锁定确保数据库实例的唯一性，避免资源浪费和数据不一致
2. **数据库迁移**：定义明确的Migration对象，确保应用升级时用户数据不丢失
3. **多线程访问**：在后台线程执行数据库操作，防止UI卡顿
4. **软删除**：使用deleted字段标记任务删除状态，支持数据恢复
5. **类型转换**：使用TypeConverter简化复杂数据类型的存储
6. **关系查询**：通过外键关系查询相关数据
7. **事务处理**：使用@Transaction注解确保数据完整性
8. **LiveData集成**：提供可观察的数据源，实现UI自动更新

```java
// 事务处理示例
@Dao
public interface TransactionDao {
    @Transaction
    default void updateTaskAndGroup(Todo task, TaskGroup group) {
        updateTodo(task);
        updateTaskGroup(group);
    }
    
    @Update
    void updateTodo(Todo todo);
    
    @Update
    void updateTaskGroup(TaskGroup taskGroup);
}
```

## 关系型数据库设计原则

ToDoList应用的数据库设计遵循了以下关系型数据库设计原则：

### 1. 数据正规化

应用了第三范式设计，确保每个表都有明确的主键，并且非键字段依赖主键：

- Todo表：使用UUID作为主键，其他字段如title、time等都直接依赖id
- TaskGroup表：使用UUID作为主键，所有属性都直接依赖id
- 避免冗余数据：通过外键引用而不是数据复制

### 2. 数据完整性

通过以下机制确保数据完整性：

- **实体完整性**：使用@PrimaryKey和@NonNull确保主键存在且唯一
- **参照完整性**：通过groupId外键关联建立任务与任务组的关系
- **域完整性**：使用适当的数据类型和默认值约束

### 3. 索引策略

针对不同的查询需求设计了合理的索引：

```java
@Entity(
    tableName = "todos",
    indices = {
        @Index("time"),            // 优化按时间查询
        @Index("category"),        // 优化按类别查询
        @Index("groupId"),         // 优化按任务组查询
        @Index(value = "deleted")  // 优化筛选未删除记录
    }
)
public class Todo {
    // 类定义...
}
```

### 4. 查询优化

针对频繁执行的复杂查询进行了优化：

```java
// 高效查询：获取今日任务
@Query("SELECT * FROM todos WHERE deleted = 0 AND time >= :startOfDay AND time < :endOfDay ORDER BY time ASC")
List<Todo> getTodayTodos(long startOfDay, long endOfDay);

// 避免使用*通配符，只查询需要的字段
@Query("SELECT id, title, time, completed FROM todos WHERE deleted = 0 ORDER BY time ASC")
List<TodoSummary> getTodoSummaries();
```

通过这些设计和实践，ToDoList应用实现了高效、可靠的本地数据存储和访问，为用户提供了良好的应用体验，同时也为开发者提供了清晰的数据层架构。 